# C++ 20 모듈 시스템 
C++20.. 에 수많은 것들이 추가되는데. 아마 적용되자마자 가장 빠르게 코드가 난독화 될(...) 모듈 시스템을 초간단 요약해봤습니다.

이제 모듈 시스템으로 헤더 <-> 소스 파일 구분이 불필요해졌습니다. 물론. 기존의 include도 지원합니다! 즉, 둘 다 알아야 할 수도 있습니다! ;ㅁ;...

우선 예제코드를 보시죠 :

```cpp
//module.cpp
exprot module hello;

export const char * get_hello() { return "Hello!, World!";  }
const char * get_not_hello() { return "Hello!, World!"; }
```

이제 이 파일을 들고올때는 간단히 아래와 같이 적으면 됩니다. 

```cpp
//main.cpp
import hello; 
import <iostream>; //기존 헤더파일도 이렇게 들고 올 수 있습니다. 세미클론은 필수 입니다.  

int main ()
{
	get_hello(); //컴파일 성공! 
	//get_not_hello(); //컴파일 실패..
}

```

바깥으로 들고오려면, 앞에 export를 선언해주면 됩니다.

모듈 시스템의 기능중 하나는 모듈을 파티션별로 나눌 수 있습니다. 한 모듈안에 여러개의 파일이 포함될 수 있습니다! 

```cpp 
//module.cpp
export module hello; 
//이 선언은 별개의 모듈을 선언한게 아니라
//이 모듈의 부분들을 선언한겁니다. 
//둘의 차이점은, 별개의 모듈(아래 설명할 서브모듈)은 분리가 가능하지만. 
//모듈의 부분은 (파티션)은 분리가 불가능합니다. 
export import :eng;
export import :ko;
//중요한 점은, *반드시* 모든 파티션들을 선언해줘야 합니다. 직접적으로든, 간접적으로든. 이는 C++ 표준상 제약이며, 미정의 행동을 유발할 수 있습니다.
```

```cpp 
//module_eng.cpp
//모듈 분리! 이건 모듈의 부분입니다. 
export module hello:eng; 

export const char * get_hello_eng()
{ return "Hello, World!";}

```

```cpp 
//module_ko.cpp
//모듈 분리! 이건 모듈의 부분입니다. 
export module hello:ko; 

export const char * get_hello_ko()
{ return "안녕, 세상!";}
```

```cpp 
//main.cpp
import hello:eng; 
import <iostream>

int main()
{
	std::cout << get_hello_eng() << get_hello_ko(); //정상 작동! 
}
```

모듈 시스템에서도 구현단과 정의단의 분리가 가능합니다. 

```cpp 
//module.cpp
//모듈 구현 분리! 여기서 선언만 해줍니다.
export module hello;
import :ko; //여기서 정의하면, export할 필요가 없습니다. 

const char * get_hello_ko(); //선언! 
```

```cpp 
//module_ko.cpp
//모듈 분리! 이건 모듈의 부분입니다. 
module hello:ko; //역시 export해주지 않아도 됩니다. 

const char * get_hello_ko() //정의!
{ return "안녕, 세상!";}
```

문법상으로 C#의 System.Text와 같은 서브모듈의 분리가 가능한 것 '처럼' 보이지만, 실제 구현상으론 그냥 별개의 모듈로 작동합니다. 이게 구현되지 않은 이유는 C++의 언어 특징에 밀접하게 관련이 있습니다 .

C++은 네이티브 언어이기에, API뿐만 아니라 ABI도 신경써야 합니다. 예를 들어 System과 System.Sub, System.Main이 있을 때. import System.Main을 했다고 해봅시다. 

만약 C++이 다른 언어와 같이 완벽한 서브모듈을 지원하려면 System.Main은 System에 탈부착이 가능해야합니다. 하지만 앞서 말했듯, C++은 네이티브 언어로 ABI가 필요합니다. 즉, 어셈블리 언어가 능동적으로 메인 모듈에 붙였다 때져야하는데,  네이티브는 그럴 수 없으므로 파이썬과 같은 서브 모듈은 불가능합니다. 

다만 이름이 'System', 'System.Submodule'인 건 여전히 가능합니다. 기술적으로는 아무런 의미가 없고, 바이너리도 독립적으로 나오겠지만 구분짓는데에는 도움이 될 수도 있겠지요. 

참고 : 
[Understanding C++ Modules: Part 1: Hello Modules, and Module Units](https://vector-of-bool.github.io/2019/03/10/modules-1.html)ㅣ

사실상 위 포스터의 요약 & 번역문입니다. 자세한 사항은 저 블로그를 참고해주세요! 

#Development/R&D
#Development/C++/C++20